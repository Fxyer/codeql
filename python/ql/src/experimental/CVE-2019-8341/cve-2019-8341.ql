/**
 * @name SSTI in Jinja2 (CVE-2019-8341)
 * @description Server-side template injection occurs when user-controlled input is embedded into a server-side template, allowing users to inject template directives.
 * @kind SSTI
 */

import python
import semmle.python.security.Paths
import semmle.python.web.HttpRequest
import semmle.python.dataflow.TaintTracking
import semmle.python.security.strings.Untrusted


predicate isObjectAttribute(Expr e, string objectName, string methodName) {
    e.(Call).getFunc().(Attribute).getName().toString() = methodName
    and e.(Call).getFunc().(Attribute).getObject().toString() = objectName
  }


class SSTIStringEvaluationNode extends TaintSink {
    override string toString() { result = "SSTI in Jinja2 (CVE-2019-8341)" }
    SSTIStringEvaluationNode() {
        exists(Expr e | isObjectAttribute(e, "Jinja2", "from_string"))
    }
    override predicate sinks(TaintKind kind) { kind instanceof ExternalStringKind }
}


class SSTIConfiguration extends TaintTracking::Configuration {
    SSTIConfiguration() { this = "Server Side Template Injection" }

    override predicate isSource(TaintTracking::Source source) {
        source instanceof HttpRequestTaintSource
    }

    override predicate isSink(TaintTracking::Sink sink) { sink instanceof SSTIStringEvaluationNode }
}

from SSTIConfiguration config, TaintedPathSource src, TaintedPathSink sink
where config.hasFlowPath(src, sink)
select sink.getSink(), src, sink, "$@ flows to here and is interpreted as code.", src.getSource(), "A user-provided value"

